<!DOCTYPE html>
<html lang="en">
  <head lang="en">
    <title>Lab 4: 32-bit ALU</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <meta name="viewport" content="width=870">

    <script> MathJax = { tex: { inlineMath: [['$','$'],['\\(','\\)']], processEscapes: true}}; </script>
    <script src="../tools/MathJax/tex-chtml.js" id="MathJax-script" async></script>
    <script src="../tools/jquery-3.2.1.min.js"></script>
    <link rel="stylesheet" href="../tools/github.css">
    <link rel="stylesheet" href="../tools/labs.css">
    <link rel="stylesheet" href="../tools/font-awesome.css">
    <script src="../tools/answers.js"></script>
  </head>

  <body>
    <article class="markdown-body">
      <div style="margin: 10px; border: 1px solid black; padding: 10px; background-color: #FFE;">
        All your exercise answers for this page are saved by the browser in local storage
        associated with this page.  You can use the buttons below
        to load/save the answers on your system.  Note that loading will overwrite
        any answers currently saved by the browser.
        <br>
        <center>
          Save: <a download="saved_lab_4.json" href="#" onclick="answers.save_answers(this);"><button>Save</button></a>
          <span style="margin-left: 2em;">Load:</span>
          <input id="filename" type="file"/>
          <button onclick="answers.load_answers(document.getElementById('filename'));">Load</button>
        </center>
      </div>

      <h2>Lab 4: 32-bit ALU</h2>

      <p>When entering numeric values in the answer fields, you can use
        integers (1000, 0x3E8, 0b1111101000), floating-point numbers
        (1000.0), scientific notation (1e3), engineering scale factors
        (1K), or numeric expressions (3*300 + 100).</p>

      <p>Useful links:</p>
      <ul>
        <li><a href="/labs/tool_docs/jade.html" target="_blank">Introduction to Jade</a></li>
        <li><a href="/labs/tool_docs/stdcell.html" target="_blank">Standard Cell Library</a></li>
      </ul>

      <h3>Problem 1. Design Problem: 32-bit Arithmetic and Logic Unit</h3>

      <p>See the instructions below.</p>

      <p>Use the Jade instance below to enter your design. To complete this
        design problem, select the /alu/alu module and click <i class="fa fa-check" style="color:green;"></i>
        in the Jade toolbar and the built-in tester
        will either report any discrepencies between the expected and actual
        outputs, or, if your design is correct, it will record the test passed.</p>

      <answer id="alu" type="window" tool_name="Jade" height="500" src="../tools/jade_workbook.html"
              placeholder="Enter the required circuitry using the interactive schematic editor, then click &#x3C;span style=&#x22;color:green;&#x22;&#x3E;&#x2714;&#x3c;/span&#x3E; in the tool bar of the Schematic tab to run the provided tests."><![CDATA[
      { "shared_modules": [ "../lab4_alu/alu_modules.json" ],
        "hierarchical": "true",
        "parts": ["/gates/.*","/alu/.*","/user/.*"],
        "tools": ["check"],
        "editors": ["schematic","icon","test"],
        "edit": "/alu/alu",
        "required_tests": ["936fccfa4372c323a3f696b9fa670991"]
      }
]]></answer>

      <p>In this lab, we&#700;ll build the arithmetic and logic unit (ALU) for
        the Beta processor.  The ALU has two 32-bit inputs (which we&#700;ll call
        "A" and "B") and produces one 32-bit output.  We&#700;ll start by designing
        each piece of the ALU as a separate circuit, each producing its own
        32-bit output.  Then we&#700;ll combine these outputs into a single ALU
        result.</p>

      <p>When designing circuitry there are three separate factors that can
        be optimized:</p>

      <ol>
        <li> design for maximum performance (minimum latency)</li>
        <li> design for minimum cost (minimum area)</li>
        <li> design for the best cost/performance ratio (minimize area*latency)</li>
      </ol>

      <p>Happily it&#700;s often possible to do all three at once but in some
        portions of the circuit some sort of design tradeoff will need to be
        made.  When designing your circuitry you should choose which of these
        three factors is most important to you and optimize your design
        accordingly.</p>

      <p><b>The standard cell library &amp; gate-level simulation</b></p>

      <p>The building blocks for this lab come from a library of logic
        gates &mdash; IC manufacturers often have a "standard cell library" and
        various design tools to make it easier for their customers to design
        without worrying about the detailed geometry of the mask layers used
        to create mosfets and wiring.  6.004 has its own
        <a href="/labs/tool_docs/stdcell.html" target="_blank">Standard Cell Library</a>
        which provides:</p>
      <div style="margin-left:2em; margin-bottom: 1em;">
        inverter, buffers, tristate driver<br/>
        2-, 3- and 4-input AND, OR, NAND and NOR gates<br/>
        2-input XOR and XNOR gates<br/>
        2:1 and 4:1 multiplexors<br/>
        D-register and D-latches
      </div>
      <p>See the library documentation for details on the appropriate connections
        for each gate.  In Jade, the gates in the standard cell library can be
        found in the parts bin under "/gates/".</p>

      <p>Since we&#700;re designing at the gate level we can use a faster
        simulator that only knows about gates and logic values (instead of
        transistors and voltages).  Note that your design can&#700;t contain any
        mosfets, resistors, capacitors, etc.; the gate-level simulator only supports the
        gate primitives in the standard cell library.</p>

      <p>Inputs are still specified in terms of voltages (to maintain
        netlist compatability with the other simulators) but the gate-level
        simulator converts voltages into one of three possible logic values
        using the <tt>vil</tt> and <tt>vih</tt> thresholds specified at the
        beginning of your design file:</p>

      <div style="margin-left:2em; margin-bottom: 1em;">
        <tt>0</tt> logic low (voltages less than or equal to <tt>vil</tt> threshold)<br/>
        <tt>1</tt> logic high (voltages greater than or equal to <tt>vih</tt> threshold)<br/>
        <tt>X</tt> unknown or undefined (voltages between the thresholds, or unknown voltages)
      </div>

      <p>A fourth value "Z" is used to represent the value of nodes that
        aren&#700;t being driven by any gate output (<i>e.g.</i>, the outputs of tristate
        drivers that aren&#700;t enabled).  The following diagram shows how these
        values appear on the waveform display:</p>

      <p><center><img src="12.png" alt="waveforms"/></center></p>

      <p><b>ALU specification</b></p>

      <p>
        <img src="10.png" style="float:right; margin-left: 10px;"/>

        The 32-bit ALU we will build will be a component in the Beta
        processor we will address in subsequent laboratories.  The logic
        symbol for our ALU is shown to the right.  It is a combinational
        circuit taking two 32-bit data words A and B as inputs, and producing
        a 32-bit output Y by performing a specified arithmetic or logical
        function on the A and B inputs.  The particular function to be
        performed is specified by a 6-bit control input, FN, whose value
        encodes the function according to the following table:</p>

      <p style="clear:right;"/>
      <table border="1" cellpadding="5" style="border-collapse:collapse;">
        <tr><th>FN[5:0]</th><th>Operation</th><th>Output value Y[31:0]</th></tr>
        <tr><td align="center"><tt>00-011</tt></td><td>CMPEQ</td><td>Y = (A == B)</td></tr>
        <tr><td align="center"><tt>00-101</tt></td><td>CMPLT</td><td>Y = (A &lt; B)</td></tr>
        <tr><td align="center"><tt>00-111</tt></td><td>CMPLE</td><td>Y = (A &le; B)</td></tr>
        <tr><td align="center"><tt>01---0</tt></td><td>32-bit ADD</td><td>Y = A + B</td></tr>
        <tr><td align="center"><tt>01---1</tt></td><td>32-bit SUBTRACT</td><td>Y = A - B</td></tr>
        <tr><td align="center"><tt>10<i>abcd</i></tt></td><td>Bit-wise Boolean</td><td>Y[i] = F<sub>abcd</sub>(A[i],B[i])</td></tr>
        <tr><td align="center"><tt>11--00</tt></td><td>Logical Shift left (SHL)</td><td>Y = A &lt;&lt; B</td></tr>
        <tr><td align="center"><tt>11--01</tt></td><td>Logical Shift right (SHR)</td><td>Y = A &gt;&gt; B</td></tr>
        <tr><td align="center"><tt>11--11</tt></td><td>Arithmetic Shift right (SRA)</td><td>Y = A &gt;&gt; B (sign extended)</td></tr>
      </table>

      <p>Note that by specifying an appropriate value for the 6-bit FN
        input, the ALU can perform a variety of arithmetic operations,
        comparisons, shifts, and bitwise Boolean combinations required by our
        Beta processor.</p>

      <p><div style="float:right; margin-left: 10px;">
          <table border="1" cellpadding="3" style="border-collapse:collapse">
            <tr><td>B<sub>i</sub></td><td>A<sub>i</sub></td><td>Y<sub>i</sub></td></tr>
            <tr><td>0</td><td>0</td><td><tt><i>d</i></tt></td></tr>
            <tr><td>0</td><td>1</td><td><tt><i>c</i></tt></td></tr>
            <tr><td>1</td><td>0</td><td><tt><i>b</i></tt></td></tr>
            <tr><td>1</td><td>1</td><td><tt><i>a</i></tt></td></tr>
          </table>
        </div>
        The bitwise Boolean operations are specified by FN[5:4]=10; in this
        case, the remaining FN bits <tt><i>abcd</i></tt> are taken as
        entries in the truth table describing how each bit of Y is determined
        by the corresponding bits of A and B, as shown to the right.</p>

      <p>The three compare operations each produce a Boolean output.  In
        these cases, Y[31:1] are all zero, and the low-order bit Y[0] is a 0
        or 1 reflecting the outcome of the comparison between the 32-bit A and
        B operands.</p>

      <p>We can approach the ALU design by breaking it down into subsystems
        devoted to arithmetic, comparison, Boolean, and shift operations as
        shown below:</p>

      <p><center><img src="11.png" width="500"/></center></p>

      <p>Designing a complex system like an ALU is best done in stages,
        allowing individual subsystems to be designed and debugged one at a
        time.  The steps below follow that approach to implementing the ALU
        block diagram shown above.  We begin by implementing an ALU
        framework with dummy modules for each of the four major subsystems
        (BOOL, ARITH, CMP, and SHIFT); we then implement and debug real
        working versions of each subsystem.  To help you follow this path, we
        provide separate tests for each of the four component modules.</p>

      <p>NOTE: the FN signals used to control the operation of the ALU
        circuitry use an encoding chosen to make the design of the ALU
        circuitry simple.  This encoding is not the same as the one used to
        encode the 6-bit opcode field of Beta instructions.  In Lab 7, you&#700;ll
        build some logic (actually a ROM) that will translate the opcode field
        of an instruction into the appropriate FN control bits.</p>

      <p>There are design notes below suggesting how to go about the design
        for each of the sub-modules.</p>

      <p><b>BOOL unit</b></p>

      <p> Design the circuitry to implement the Boolean operations for
        your ALU and use it to replace the jumper and wire that connects the Y[31:0]
        output to ground.</p>

      <img src="13.png" width="200" style="float:right; margin-left: 10px;"/>
      <p>The suggested implementation uses 32 copies of a 4-to-1
        multiplexor (<tt>mux4</tt>) where <tt>BFN[3:0]</tt> encode the operation to
        be performed and A[31:0] and B[31:0] are hooked to the multiplexor&#700;s select
        inputs.  This implementation can produce any of the 16 2-input Boolean
        functions.</p>

      <div class="hint" style="clear: both;">
        <p>Hint: Jade will automatically replicate a logic gate to match the width of
          the gate&#700;s inputs and outputs to the width of the signals that connect
          to the gate.</p>

        <p>For example, the MUX4 gate shown above has a 1-bit output signal,
          which in this schematic is hooked to Y[31:0], a signal of width 32.
          So Jade will replicate the MUX4 32 times, the output of the first MUX4
          connects to Y[31], the output of the second MUX4 connects to Y[30],
          and so on.</p>

        <p>The input signals are then replicated (if necessary) to provide
          the inputs for each of the 32 MUX4 gates.</p>

        <p>Each MUX4 gate requires 2 select signals, which are
          taken from the 64 signals provided.  B[31] and A[31] connect to the select lines of the first
          MUX4, B[30] and A[30] connect to the select lines of the second MUX4,
          and so on.</p>

        <p>Each MUX4 gate requires 4 data signals. The specified BFN inputs
          are only 1 bit wide, so the specified signals are each replicated 32
          times, <i>e.g.</i>, BFN[0] is used as the D0 input for each of the 32 MUX4s.</p>
      </div>

      <p>The following table shows the encodings for some of the BFN[3:0]
        control signals used by the test jig (and in our typical Beta
        implementations):</p>

      <p><center><table cellspacing="5">
            <tr><th>Operation</th><th>BFN[3:0]</th></tr>
            <tr><td>AND</td><td><tt>1000</tt></td></tr>
            <tr><td>OR</td><td><tt>1110</tt></td></tr>
            <tr><td>XOR</td><td><tt>0110</tt></td></tr>
            <tr><td>"A"</td><td><tt>1010</tt></td></tr>
      </table></center></p>

      <p>The BOOL test actually checks all 16 boolean operations on a
        selection of arguments, and will report any errors that it finds.</p>

      <p>When your BOOL circuitry has been entered, run the test
        by clicking the green checkmark; a simulation plot window showing the inputs and
        outputs should appear.  Jade will check your circuit&#700;s results against a list of
        expected values and report any discrepancies it finds.</p>

      <div class="hint">
        <p>Hint: What do I do when the verification fails?</p>

        <p>The failure notification will tell you which signal failed
          verification and the simulated time at which the mismatch between the
          actual value and expected occurred.  The tests are actually a sequence
          of 100ns testing cycles and the reported time will be at the
          end of one of the cycles when the output values are checked for
          correctness.</p>

        <p>Move your mouse over the plot of the appropriate signal waveform
          until the vertical time cursor is approximately at the failure time.
          Then double-click to zoom in on the plots around that particular time;
          zoom in enough so that all the signals for that testing cycle are
          readable.  Now you can figure out what the circuit was being asked to
          do for that particular test and, hopefully, deduce why your circuit is
          producing an incorrect output.</p>
      </div>

      <p><b>ARITH unit</b></p>

      <p>Design an adder/subtractor (ARITH) unit that operates on 32-bit
        two&#700;s complement inputs and generates a 32-bit output.  It will be
        useful to generate three other output signals to be used by the CMP
        unit: <tt>Z</tt> which is true when the <tt>S</tt> outputs are all
        zero, <tt>V</tt> which is true when the addition operation overflows
        (<i>i.e.</i>, the result is too large to be represented in 32 bits),
        and <tt>N</tt> which is true when the sum is negative (<i>i.e.</i>, <tt>S[31]</tt> = 1).
        Overflow can never occur when the two operands to the addition have
        different signs; if the two operands have the same sign, then overflow
        can be detected if the sign of the result differs from the sign of the
        operands:</p>

      <p><center>
          \(V = XA_{31}\cdot XB_{31}\cdot \overline{S_{31}} + 
          \overline{XA_{31}}\cdot\overline{XB_{31}}\cdot S_{31}\)</center></p>

      <p>Note that this equation uses <tt>XB[31]</tt>, which is the high-order bit of
        the B operand to the adder itself (<i>i.e.</i>, after the XOR gate &mdash; see the
        schematic below). <tt>XA[31]</tt> is simply <tt>A[31]</tt>.</p>

      <p>The following schematic is one suggestion for how to go about the
        design:</p>

      <p><center><img src="15.png" width="500"/></center></p>

      <p><tt>AFN</tt> will be set to 0 for an ADD (\(S = A+B\)) and 1 for a
        SUBTRACT (\(S = A-B\)); <tt>A[31:0]</tt> and <tt>B[31:0]</tt> are the
        32-bit two&#700;s complement input operands; <tt>S[31:0]</tt> is the 32-bit
        result; <tt>Z</tt>/<tt>V</tt>/<tt>N</tt> are the three condition code
        bits described above.  We&#700;ll be using the "little-endian" bit
        numbering convention where bit 31 is the most-significant bit and bit
        0 is the least-significant bit.</p>

      <p>We&#700;ve provided a FA module for entering the gate-level schematic
        for the full adder (see Problem 8 of Lab #1) to be used in constructing
        the 32-bit ripple carry adder that forms the heart of the ARITH unit.</p>

      <p>The <tt>AFN</tt> input signal selects whether the operation
        is an ADD or SUBTRACT.  To do a SUBTRACT, the circuit first computes
        the two&#700;s complement negation of the B operand by inverting B and
        then adding one (which can be done by forcing the carry-in of the
        32-bit add to be 1).  Start by implementing the 32-bit add using a
        ripple-carry architecture (you&#700;ll get to improve on this later on in
        the course).  You&#700;ll have to construct the 32-input NOR gate required
        to compute <tt>Z</tt> using a tree of smaller fan-in gates (the parts
        library only has gates with up to 4 inputs).</p>

      <p>When entering your circuitry, remember to delete the original
        jumpers and wires that connected the outputs to ground!</p>

      <p>The module test tries adding and subtracting various operands,
        ensuring that the <tt>Z</tt>, <tt>V</tt> and <tt>N</tt> outputs are
        correct after each operation.</p>

      <p><b>CMP unit</b></p>

      <p>The ALU provides three comparison operations for the A and B
        operands.  We can use the adder unit designed above to compute \(A-B\)
        and then look at the result (actually just the <tt>Z</tt>, <tt>V</tt> and <tt>N</tt> condition
        codes) to determine if A=B, A &lt; B or A &le; B.  The compare
        operations generate a 32-bit result using the number 0 to represent
        false and the number 1 to represent true.</p>

      <p>Design a 32-bit compare (CMP) unit that generates one of two
        constants (0 or 1) depending on the <tt>CFN[1:0]</tt> control signals (used to
        select the comparison to be performed) and the <tt>Z</tt>, <tt>V</tt>, and <tt>N</tt> outputs of
        the adder/subtractor unit.  Clearly the high order 31 bits of the
        output are always zero.  The least significant bit (LSB) of the output is
        determined by the comparison being performed and the results of the
        subtraction carried out by the adder/subtractor:</p>

      <p><center><table cellpadding="3">
            <tr><th>Comparison</th><th>Equation for LSB</th><th>CFN[1:0]</th></tr>
            <tr align="center"><td>A = B</td><td>LSB = \(Z\)</td><td>01</td></tr>
            <tr align="center"><td>A &lt; B</td><td>LSB = \(N \oplus V\)</td><td>10</td></tr>
            <tr align="center"><td>A &le; B</td><td>LSB = \(Z + (N \oplus V)\)</td><td>11</td></tr>
      </table></center></p>

      <p>At the level of the ALU module, <tt>FN[2:1]</tt> are used to control the compare unit since we
        need to use <tt>FN[0]</tt> to control the adder/subtractor unit to force a subtract.</p>

      <p>Performance note: the <tt>Z</tt>, <tt>V</tt> and <tt>N</tt> inputs to this circuit can only
        be calculated by the adder/subtractor unit after the 32-bit add is
        complete.  This means they arrive quite late and then require further
        processing in this module, which in turn makes <tt>Y[0]</tt> show up very late
        in the game.  You can speed things up considerably by thinking about
        the relative timing of <tt>Z</tt>, <tt>V</tt> and <tt>N</tt> and then designing your logic to
        minimize delay paths involving late-arriving signals.</p>

      <p>The module test ensures that the correct answer is generated for all possible
        combinations of <tt>Z</tt>, <tt>V</tt>, <tt>N</tt> and <tt>CFN[1:0]</tt>.</p>

      <p><b>SHIFT unit</b></p>

      <p>Design a 32-bit shifter that implements logical left shift (SHL),
        logical right shift (SHR) and arithmetic right shift (SRA) operations.
        The A operand supplies the data to be shifted and
        the low-order 5 bits of the B operand are used as the shift count
        (<i>i.e.</i>, from 0 to 31 bits of shift).  The desired operation will be
        encoded on <tt>SFN[1:0]</tt> as follows:</p>

      <p><center><table cellpadding="3">
            <tr><th>Operation</th><th>SFN[1:0]</th></tr>
            <tr align="center"><td>SHL (shift left)</td><td><tt>00</tt></td></tr>
            <tr align="center"><td>SHR (shift right)</td><td><tt>01</tt></td></tr>
            <tr align="center"><td>SRA (shift right with sign extension )</td><td><tt>11</tt></td></tr>
      </table></center></p>

      <p>With this encoding, <tt>SFN[0]</tt> is 0 for a left shift and 1
        for a right shift and <tt>SFN[1]</tt> controls the sign extension logic on
        right shift.  For SHL and SHR, 0&#700;s are shifted into the vacated bit
        positions.  For SRA ("shift right arithmetic"), the vacated bit
        positions are all filled with A[31], the sign bit of the original data
        so that the result will be the same as dividing the original data by
        the appropriate power of 2.</p>

      <p>The simplest implementation is to build two shifters &mdash; one
        for shifting left and one for shifting right &mdash; and then use a
        2-way 32-bit multiplexer to select the appropriate answer as the
        module&#700;s output.  It&#700;s easy to build a shifter after noticing that a
        multi-bit shift can be accomplished by cascading shifts by various
        powers of 2.  For example, a 13-bit shift can be implemented by a
        shift of 8, followed by a shift of 4, followed by a shift of 1.  So
        the shifter is just a cascade of multiplexers each controlled by one
        bit of the shift count.  The schematic below shows a possible
        implementation of the left shift logic; the right shift logic is
        similar with the slight added complication of having to shift in
        either 0 (<i>i.e.</i>, "gnd") or <tt>A[31]</tt>, depending on the value of
        <tt>SFN[1]</tt>.  Another approach that saves gates is to use the left
        shift logic for both left and right shifts, but for right shifts,
        reverse the bits of the A operand on the way in and reverse the bits
        of the output on the way out.</p>

      <p><center><img src="16x.png" width="600"/></center></p>

      <p>The module test checks that all three types of shifts are
        working correctly.</p>

      <p><b>Final tests</b></p>

      <p>When you&#700;ve completed the design of the four sub-modules, select
        the ALU module and run its test.  This runs each of the test suites
        that you&#700;ve used to debug the component subcircuits, so unless there&#700;s
        some unforeseen interaction among your blocks you&#700;re likely to pass
        the test.  When this test completes successfully, the system will mark
        your design as complete.</p>

      <h3>Problem 2. Testing the ALU</h3>

      <p>In this lab&#700;s design problem (see above), you&#700;ll be building
        a 32-bit arithmetic and logic unit (ALU) that performs arithmetic
        and logic operations on 32-bit operands, producing a 32-bit result.
        You&#700;ll use this circuit in the design of the Beta later this
        semester.  You may want to work on the design problem first and
        come back to this problem.</p>

      <p>The test for this lab verifies your ALU circuitry by
        applying 186 different sets of input values.  This question
        explores how those values were chosen.</p>

      <p>No designer I know thinks testing is fun &mdash; designing the
        circuit seems so much more interesting than making sure it works.
        But a buggy design isn&#700;t much fun either!  Remember that a good
        engineer not only <i>knows</i> how to build good designs but also
        <i>actually</i> builds good designs, and that means testing the
        design to make sure it does what you say it does.</p>

      <p>An obvious way to test a combinational circuit is to try all
        possible combinations of inputs, checking for the correct output
        values after applying each input combination.  This type of
        <i>exhaustive test</i> proves correct operation by enumerating the
        truth table of the combinational device.  This is a workable
        strategy for circuits with a few inputs but quickly becomes
        impractical for circuits with many inputs.  By taking advantage of
        information about how the circuit is constructed we can greatly
        reduce the number of input combinations needed to test the circuit.</p>

      <p>The ripple-carry adder architecture suggested in the Design Problem uses 32
        copies of the <b>full adder</b> module to create a 32-bit adder.
        Each full adder has 3 inputs (A, B, CI) and two outputs (S, CO):</p>

      <p><center><img src="1.gif" alt="full adder"/></center></p>

      <ol type="A">

        <li>A single <i>test vector</i> for the full adder consists of 3 input
          values (one each for A, B and CI) and 2 output values (S and CO).
          To run a test the input values from the current test vector are
          applied to the device under test and then the actual output values
          are compared against the expected values listed by the test
          vector.  This process is repeated until all the test vectors have
          been used.  Assuming we know nothing about the internal circuitry
          of the full adder, how many test vectors would we need to
          exhaustively test its functionality?</li>

        <answer type="number" id="1A" width="20">
          <label>Number of test vectors to exhaustively test full adder?</label>
        </answer>

        <li>Consider a 32-bit adder with 64 inputs (two 32-bit input operands,
          assume CIN is tied to ground as shown in the diagram below)
          and 32 outputs (the 32-bit result).  Assume we don&#700;t know anything
          about the internal circuitry and so can&#700;t rule out the possibility
          that it might get the wrong answer for any particular combination
          of inputs.  In other words, just because the adder got the correct
          answer for 2 + 3 doesn&#700;t allow us to draw any conclusions about
          what answer it would get for 2 + 7.  If we could apply one test
          vector every 100ns, how long would it take to exhaustively test
          the adder?</li>

        <answer type="number" id="1B" width="20">
          <label>Time to exhaustively test 32-bit adder? (in years)</label>
        </answer>

        <li>
          <p>Clearly, testing a 32-bit adder by trying all combinations of
            input values isn&#700;t a good plan!
            Shown below is a schematic for a 32-bit ripple-carry adder.</p>

          <p><center><img src="2.gif" width="500"/></center></p>

          <p>Except for the carry-in from the bit to the right, each bit of
            the adder operates independently.  We can use this observation to
            test the adder bit-by-bit and with a bit of thought we can
            actually run many of these tests in parallel.  In this case the
            fact that the adder got the correct answer for 2 + 3 actually
            tells us a lot about the answer it will get for 2 + 7.  Since the
            computation done by adder bits 0 and 1 is same in both cases, if
            the answer for 2 + 3 is correct, the low-order two bits of the
            answer for 2 + 7 will also be correct.</p>

          <p>So our plan for testing the ripple-carry adder is to test each
            full adder independently.  When testing bit N we can set A[N] and
            B[N] directly from the test vector.  It takes a bit more work to
            set CI[N] to a particular value, but we can do it with the correct
            choices for A[N-1] and B[N-1].</p>

          <p>If we want to set CI[N] to 0, what values should A[N-1] and B[N-1]
            be set to?  If we want to set CI[N] to 1?  Assume that we can&#700;t
            assume anything about the value of CI[N-1].</p>

          <answer type="menu" id="1C1">
            <label>Values of A[N-1] and B[N-1] to make C[N]=0?</label>
            <menuitem>A[N-1]=0, B[N-1]=0</menuitem>
            <menuitem>A[N-1]=1, B[N-1]=0</menuitem>
            <menuitem>A[N-1]=0, B[N-1]=1</menuitem>
            <menuitem>A[N-1]=1, B[N-1]=1</menuitem>
          </answer>
          <answer type="menu" id="1C2">
            <label>Values of A[N-1] and B[N-1] to make C[N]=1?</label>
            <menuitem>A[N-1]=0, B[N-1]=0</menuitem>
            <menuitem>A[N-1]=1, B[N-1]=0</menuitem>
            <menuitem>A[N-1]=0, B[N-1]=1</menuitem>
            <menuitem>A[N-1]=1, B[N-1]=1</menuitem>
          </answer>

          <p>With this strategy we can test the even bits of the adder in
            parallel with one set of test vectors and test the odd bits of the
            adder in parallel with another set of test vectors.  Here&#700;s a set
            of 10 test vectors that should test all combinations of input values
            for each FA in a 32-bit ripple-carry adder:</p>

          <p><center><table border="1" cellpadding="3" style="border-collapse:collapse;font-family:monospace">
                <tr><th>bits 0, 2, ...</th><th>bits 1, 3, ...</th><th>A[31:0]</th><th>B[31:0]</th></tr>
                <tr><td>A=0, B=0, CI=0</td><td>A=0, B=0, CI=0</td><td>0x00000000</td><td>0x00000000</td></tr>
                <tr><td>A=1, B=0, CI=0</td><td>A=0, B=0, CI=0</td><td>0x55555555</td><td>0x00000000</td></tr>
                <tr><td>A=0, B=1, CI=0</td><td>A=0, B=0, CI=0</td><td>0x00000000</td><td>0x55555555</td></tr>
                <tr><td>A=1, B=1, CI=0</td><td>A=0, B=0, CI=1</td><td>0x55555555</td><td>0x55555555</td></tr>
                <tr><td>A=0, B=0, CI=0</td><td>A=1, B=0, CI=0</td><td>0xAAAAAAAA</td><td>0x00000000</td></tr>
                <tr><td>A=0, B=0, CI=0</td><td>A=0, B=1, CI=0</td><td>0x00000000</td><td>0xAAAAAAAA</td></tr>
                <tr><td>A=0, B=0, CI=1</td><td>A=1, B=1, CI=0</td><td>0xAAAAAAAA</td><td>0xAAAAAAAA</td></tr>
                <tr><td>A=1, B=0, CI=1</td><td>A=1, B=0, CI=1</td><td>0xFFFFFFFF</td><td>0x00000001</td></tr>
                <tr><td>A=0, B=1, CI=1</td><td>A=0, B=1, CI=1</td><td>0x00000001</td><td>0xFFFFFFFF</td></tr>
                <tr><td>A=1, B=1, CI=1</td><td>A=1, B=1, CI=1</td><td>0xFFFFFFFF</td><td>0xFFFFFFFF</td></tr>
          </table></center></p>
        </li>

        <li>
          <p>Three of the compare unit&#700;s inputs (Z, V and N) come from the
            adder/subtractor running in subtract mode computing A-B:</p>

          <div>
            <p>Z = 1 if A-B is 0</p>
            <p>N = 1 if A-B is negative (OUT[31] = 1)</p>
            <p>V = 1 if there&#700;s been an overflow.  The ALU, which only has
              an adder, computes A-B as A+(-B) = A+(~B)+1.  Let XB = ~B, the
              bit-wise complement of B. An overflow occurs if the sign
              of the result (OUT[31]) differs from the signs of the adder&#700;s operands
              (A[31], XB[31]).  Note that if the signs of A and XB differ, the
              addition cannot produce an overflow.</p>
          </div>

          <p>To test the compare
            unit, we&#700;ll need to pick operands for the adder/subtractor that
            generate all possible combinations of Z, V and N.  It&#700;s easy to
            see that any combination with Z = 1 and N = 1 is not possible
            (the output of the adder cannot be negative and zero at the same
            time!).  It also turns out that combinations with Z = 1 and V =
            1 cannot be produced by a subtract operation.</p>

          <p>For each of the combinations of Z, V and N shown below,
            choose the subtraction operation that will produce the specified
            combination of condition codes.</p>

          <answer type="menu" id="1E1">
            <label>Subtraction that produces Z=0, V=0, N=0?</label>
            <menuitem>0x12345678 - 0x12345678</menuitem>
            <menuitem>0x7FFFFFFF - 0xFFFFFFFF</menuitem>
            <menuitem>0x00000005 - 0xDEADBEEF</menuitem>
            <menuitem>0xDEADBEEF - 0x00000005</menuitem>
            <menuitem>0x80000000 - 0x00000001</menuitem>
          </answer>
          <answer type="menu" id="1E2">
            <label>Subtraction that produces Z=1, V=0, N=0?</label>
            <menuitem>0x12345678 - 0x12345678</menuitem>
            <menuitem>0x7FFFFFFF - 0xFFFFFFFF</menuitem>
            <menuitem>0x00000005 - 0xDEADBEEF</menuitem>
            <menuitem>0xDEADBEEF - 0x00000005</menuitem>
            <menuitem>0x80000000 - 0x00000001</menuitem>
          </answer>
          <answer type="menu" id="1E3">
            <label>Subtraction that produces Z=0, V=1, N=0?</label>
            <menuitem>0x12345678 - 0x12345678</menuitem>
            <menuitem>0x7FFFFFFF - 0xFFFFFFFF</menuitem>
            <menuitem>0x00000005 - 0xDEADBEEF</menuitem>
            <menuitem>0xDEADBEEF - 0x00000005</menuitem>
            <menuitem>0x80000000 - 0x00000001</menuitem>
          </answer>
          <answer type="menu" id="1E4">
            <label>Subtraction that produces Z=0, V=0, N=1?</label>
            <menuitem>0x12345678 - 0x12345678</menuitem>
            <menuitem>0x7FFFFFFF - 0xFFFFFFFF</menuitem>
            <menuitem>0x00000005 - 0xDEADBEEF</menuitem>
            <menuitem>0xDEADBEEF - 0x00000005</menuitem>
            <menuitem>0x80000000 - 0x00000001</menuitem>
          </answer>
          <answer type="menu" id="1E5">
            <label>Subtraction that produces Z=0, V=1, N=1?</label>
            <menuitem>0x12345678 - 0x12345678</menuitem>
            <menuitem>0x7FFFFFFF - 0xFFFFFFFF</menuitem>
            <menuitem>0x00000005 - 0xDEADBEEF</menuitem>
            <menuitem>0xDEADBEEF - 0x00000005</menuitem>
            <menuitem>0x80000000 - 0x00000001</menuitem>
          </answer>
        </li>
      </ol>

      <h3>Problem 3. The Versatile BOOL unit</h3>

      <div style="float:right; margin-left: 10px;">
        <table border="1" cellpadding="3" style="border-collapse:collapse">
          <tr><td>B<sub>i</sub></td><td>A<sub>i</sub></td><td>Y<sub>i</sub></td></tr>
          <tr><td>0</td><td>0</td><td><tt><i>d</i></tt></td></tr>
          <tr><td>0</td><td>1</td><td><tt><i>c</i></tt></td></tr>
          <tr><td>1</td><td>0</td><td><tt><i>b</i></tt></td></tr>
          <tr><td>1</td><td>1</td><td><tt><i>a</i></tt></td></tr>
        </table>
      </div>

      <p>As we saw in the instructions for the ALU,
        the bitwise Boolean operations are specified by FN[5:4]=10. In this
        case, the remaining FN bits <tt><i>abcd</i></tt> are taken as
        entries in the truth table describing how each bit of Y is determined
        by the corresponding bits of A and B, as shown to the right.</p>

      <p>For each of the Boolean operations \(F(A,B)\) specified
        below, determine the settings for FN[3:0] = <i>abcd</i> so
        that the Bool unit will compute desired operation.</p>

      <answer type="menu" id="3A">
        <label><tt>AND(A,B):&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3B">
        <label><tt>OR(A,B):&nbsp;&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3C">
        <label><tt>XOR(A,B):&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3D">
        <label><tt>NAND(A,B):&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3E">
        <label><tt>NOR(A,B):&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3F">
        <label><tt>XNOR(A,B):&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3G">
        <label><tt>A:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <answer type="menu" id="3H">
        <label><tt>B:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FN[3:0]=</tt></label>
        <menuitem>0000</menuitem>
        <menuitem>0001</menuitem>
        <menuitem>0010</menuitem>
        <menuitem>0011</menuitem>
        <menuitem>0100</menuitem>
        <menuitem>0101</menuitem>
        <menuitem>0110</menuitem>
        <menuitem>0111</menuitem>
        <menuitem>1000</menuitem>
        <menuitem>1001</menuitem>
        <menuitem>1010</menuitem>
        <menuitem>1011</menuitem>
        <menuitem>1100</menuitem>
        <menuitem>1101</menuitem>
        <menuitem>1110</menuitem>
        <menuitem>1111</menuitem>
      </answer>

      <div class="xyzzy">
        7579999476c6d49ca08d3d07ceef9ac7247cdc572759936ae03c51b998cba70b131be43ed8e695c2241d0a188dad8cf300d796ca0c579b2f4eb9e6d1123b0bdc6f0a5eda5618f73d7338584c33f9fb3a2131efe2cee045d4128943e9c2e3e203d04e81fc528ec59641b3dd2aa77dd3dfa64ec98cd6d99f41453d0100f854c2b1399bf176563cc8bcd908be721f716d2e5afd229d7f70d000d3107a835b64b7e5f3439e1fe3cdbbb66cf2e2bc21f8351fac1be11771bc9b4f3b4018fa584db4a7ff11c9f3b6428e1cbd96e2a44dccd970344331f842264a1c475b53edd0c0e0699ca9869f4786094e80cb2d317ebbfbac1bea825733353c83fe58bcddf9502f463d3ea6d31c3fddc7c43287a90c3e236e19fc102e1eb3a4bab3ecc10556a39a56fc3d4d62afca528a400b6187336d4568b47c69c8059066a580afc5be9db4ad1ef17265fdbcc7fb4eefc69a78a93af72ba5c6c9285bc3c0df39f7c2a3
      </div>
    </article>
  </body>
</html>
